(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.vuetifyToast = factory());
}(this, (function () { 'use strict';

var Toast = { render: function () {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('v-snackbar', { staticClass: "application", attrs: { "timeout": _vm.timeout, "color": _vm.color, "bottom": _vm.y === 'bottom', "top": _vm.y === 'top', "left": _vm.x === 'left', "right": _vm.x === 'right', "auto-height": _vm.autoHeight, "multi-line": _vm.multiLine, "vertical": _vm.vertical }, on: { "click": _vm.dismiss }, model: { value: _vm.active, callback: function ($$v) {
          _vm.active = $$v;
        }, expression: "active" } }, [!!_vm.icon ? _c('v-icon', { staticClass: "mr-4", attrs: { "dark": "", "left": "" } }, [_vm._v(" " + _vm._s(_vm.icon) + " ")]) : _vm._e(), _vm._v(" " + _vm._s(_vm.message) + " ")], 1);
  }, staticRenderFns: [],
  props: {
    x: {
      type: String,
      default: 'right'
    },
    y: {
      type: String,
      default: 'bottom'
    },
    color: {
      type: String,
      default: 'info'
    },
    icon: {
      type: String
    },
    message: {
      type: String
    },
    timeout: {
      type: Number,
      default: 3000
    },
    dismissable: {
      type: Boolean,
      default: true
    },
    autoHeight: {
      type: Boolean,
      default: false
    },
    multiLine: {
      type: Boolean,
      default: false
    },
    vertical: {
      type: Boolean,
      default: false
    }
  },

  data: function () { return ({
    active: false
  }); },

  mounted: function mounted() {
    var this$1 = this;

    this.$nextTick(function () { return this$1.show(); });
  },

  methods: {
    show: function show() {
      this.active = true;
    },

    close: function close() {
      this.active = false;
    },

    dismiss: function dismiss() {
      if (this.dismissable) {
        this.close();
      }
    }
  }
};

function init(Vue, options) {
  if ( options === void 0 ) options = {};

  var cmp = null;
  var property = options.property || '$toast';

  function createCmp(options) {
    cmp = new Vue(Toast);
    Object.assign(cmp, Vue.prototype[property].options, options);
    document.body.appendChild(cmp.$mount().$el);
  }

  function show(message, options) {
    if ( options === void 0 ) options = {};

    if (cmp) {
      cmp.close();
      Vue.nextTick(function () {
        cmp = null;
        show(message, options);
      });
      return;
    }

    options.message = message;
    return createCmp(options);
  }

  function shorts(options) {
    var colors = ['success', 'info', 'error', 'warning'];
    var methods = {};

    colors.forEach(function (color) {
      methods[color] = function (message, options) { return show(message, Object.assign({ color: color }, options)); };
    });
    if (options.shorts) {
      var loop = function ( key ) {
        var localOptions = options.shorts[key];
        methods[key] = function (message, options) { return show(message, Object.assign({}, localOptions, options)); };
      };

      for (var key in options.shorts) loop( key );
    }

    return methods;
  }

  Vue.prototype[property] = Object.assign(show, Object.assign({
    options: options
  }, shorts(options)));
}

if (typeof window !== 'undefined' && window.Vue) {
  window.Vue.use(init);
}

return init;

})));
